## About

A hands-on tutorial on elliptic curves

### Lesson 0 - defining elliptic curves

Continuous case uses geogebra


```python
import plotly
```

```python
import numpy as np
```

```python
def elliptic(p, a, b):
    x = y = np.arange(p)
    xx, yy = np.meshgrid(x,y)
    return (np.mod(yy**2, p) - np.mod(xx**3+a*xx+b, p) == 0)*1.0
```

## Finite elliptic curves

```python
import plotly.graph_objects as go

fig = go.Figure(data=go.Heatmap(z=elliptic(37, a=0, b=7), colorscale='gray'), layout=dict(width=700, height=700))
fig
```

Note symmetry about $p/2$


## Algebraic sum

Given
$$P=(x_p, y_p)$$
$$Q=(x_q, y_q)$$
What is $P + Q = -R$?

We want the (modulus) line passing through $P, Q$. The slope $m$ of that line is given by

$$m = (y_p-y_q)(x_p-x_q)^{-1} mod(p)  \quad P!=Q$$
$$ (3x_P^2+a) (2y_P)^{-1} mod(p) \quad P = Q, $$
$$a = 7 \quad \text{for bitcoin}$$

With $m$ we can obtain the $R$:
$$ x_R = (m^2 - x_P - x_Q) mod(p) $$
$$ y_r = (y_p + m(x_R-x_P)) mod(p) $$

```python
# taken from https://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception(f'modular inverse does not exist {m}')
    else:
        return x % m
```

```python
def add_mod(P, Q, p, a=7):
    x_p, y_p = P
    x_q, y_q = Q
    if (x_p == x_q)&(y_p == y_q):
        m = ((3*x_p**2+a)*modinv(2*y_p, p))%p
    else:
        m = ((y_p - y_q)*modinv(x_p-x_q, p))%p
    x_r = (m**2 - x_p - x_q)%p
    y_r = (y_p + m*(x_r-x_p))%p
    return x_r, y_r
    

add_mod((22, 6), (22, 6), p)
```

```python
def multiply_mod(P, n, p, a=7):
    P_ = P
    for _ in range(1, n+1):
        P_ = add_mod(P_, P_, p, a)
        if P_ == P:
            break
    return P_

multiply_mod((3, 6), 10, p=97, a=2)
```

How many points are in the subgroup generated by P?

1. count all points on the curve N (see [Schoof's Algorithm](https://en.wikipedia.org/wiki/Schoof%27s_algorithm))
1. find all divisors of N
1. for every divisor of N, see if $nP=0$

```python
def order(field):
    """calculate the order of the field including the point at infinity"""
    return int(field.sum()+1)

order(elliptic(37, a=-1, b=3))
```

```python
def divisors(n):
    for i in range(1, int(n / 2) + 1):
        if n % i == 0:
            yield i
    yield n
```

```python
def subgroup_order(P, p, a, b):
    N = order(elliptic(p, a, b))
    for _ in divisors(N):
        print(_)
        if multiply_mod(P, _, p=p, a=a) == P:
            return _+1

subgroup_order((2,3), p=37, a=-1, b=3)
```

```python
order(elliptic(p=29, a=-1, b=1)) # is prime!
```

```python
subgroup_order((9,24), p=29, a=-1, b=1) # should be 37 instead of 38
```

```python
fig = go.Figure(data=go.Heatmap(z=elliptic(p=29, a=-1, b=1), colorscale='gray'),
                layout=dict(width=700, height=700))
fig
```

# choosing generator point P

Trick is 
1. given N choose the sugroup order n to be a prime divisor of N
1. compute cofactor h = N/n
1. choose random point P
1. compute G=hP
1. if G != 0, then n(hP)=0 and G is a generator of the whole curve
1. if G = 0, go back to (3)

```python

```
